/**
 * EventSource handler for streaming AI suggestions.
 *
 * Uses Server-Sent Events (SSE) to progressively receive tag and link
 * suggestions as they're generated by the AI backend.
 */

import { logger } from "@/lib/logger";

const API_URL = process.env.NEXT_PUBLIC_API_URL || "http://localhost:8000";

export interface TagSuggestion {
  tag: string;
  confidence: number;
  reason: string;
}

export interface LinkSuggestion {
  note_id: string;
  title: string;
  confidence: number;
  reason: string;
}

export type StreamPhase = "idle" | "tags" | "links" | "complete" | "error";

export interface StreamCallbacks {
  onTag: (tag: TagSuggestion) => void;
  onLink: (link: LinkSuggestion) => void;
  onProgress: (phase: StreamPhase) => void;
  onComplete: () => void;
  onError: (message: string) => void;
}

interface StreamEvent {
  type: "progress" | "tag" | "link" | "complete" | "error";
  phase?: StreamPhase;
  data?: TagSuggestion | LinkSuggestion;
  message?: string;
}

/**
 * Stream AI suggestions for a note via Server-Sent Events.
 *
 * @param noteId - The ID of the note to get suggestions for
 * @param callbacks - Callbacks for handling stream events
 * @returns Cleanup function to close the connection
 */
export function streamAISuggestions(noteId: string, callbacks: StreamCallbacks): () => void {
  const streamLogger = logger.withContext("AIStream");
  const url = `${API_URL}/api/notes/${noteId}/suggest-stream`;

  streamLogger.info("Opening SSE connection", { noteId, url });

  const eventSource = new EventSource(url);

  eventSource.onopen = () => {
    streamLogger.debug("SSE connection opened");
  };

  eventSource.onmessage = (event: MessageEvent) => {
    try {
      const data: StreamEvent = JSON.parse(event.data);
      streamLogger.debug("Received SSE event", { type: data.type });

      switch (data.type) {
        case "progress":
          if (data.phase) {
            callbacks.onProgress(data.phase);
          }
          break;

        case "tag":
          if (data.data) {
            callbacks.onTag(data.data as TagSuggestion);
          }
          break;

        case "link":
          if (data.data) {
            callbacks.onLink(data.data as LinkSuggestion);
          }
          break;

        case "complete":
          streamLogger.info("Stream complete", { noteId });
          eventSource.close();
          callbacks.onProgress("complete");
          callbacks.onComplete();
          break;

        case "error":
          streamLogger.error("Stream error from server", { message: data.message });
          eventSource.close();
          callbacks.onProgress("error");
          callbacks.onError(data.message || "Unknown error");
          break;

        default:
          streamLogger.warn("Unknown event type", { type: data.type });
      }
    } catch (parseError) {
      streamLogger.error("Failed to parse SSE event", { error: parseError, data: event.data });
    }
  };

  eventSource.onerror = (error) => {
    streamLogger.error("SSE connection error", { error });
    eventSource.close();
    callbacks.onProgress("error");
    callbacks.onError("Connection lost");
  };

  // Return cleanup function
  return () => {
    streamLogger.debug("Closing SSE connection");
    eventSource.close();
  };
}

/**
 * Check if streaming is supported in this environment.
 *
 * @returns true if EventSource is available
 */
export function isStreamingSupported(): boolean {
  return typeof EventSource !== "undefined";
}
