name: Deploy to DigitalOcean

on:
  push:
    branches: [main]
    paths-ignore:
      - 'backend/static/assets/**'  # Ignore non-article assets
      - 'docs/**'  # Ignore documentation
      - 'README.md'  # Ignore root README
      # Note: We DO deploy on article changes to invalidate backend cache
  workflow_dispatch:  # Allow manual deployment

jobs:
  # Deploy to production (CI must pass first via branch protection or ci.yml trigger)
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create pre-deployment backup
        env:
          ADMIN_TOKEN: ${{ secrets.ADMIN_TOKEN }}
        run: |
          echo "üì¶ Creating pre-deployment backup..."

          # Attempt backup via API (may fail on first deployment)
          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST https://api.mongado.com/api/admin/backup \
            -H "Authorization: Bearer $ADMIN_TOKEN" \
            --max-time 300 2>&1 || echo -e "\n000")

          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | sed '$d')

          if [ "$HTTP_CODE" = "200" ]; then
            echo "‚úÖ Pre-deployment backup created successfully"
            # Only parse JSON if it's valid
            if echo "$BODY" | jq -e . >/dev/null 2>&1; then
              echo "$BODY" | jq '.'
              BACKUP_FILE=$(echo "$BODY" | jq -r '.backup_file // "unknown"')
              echo "backup_file=$BACKUP_FILE" >> $GITHUB_OUTPUT
              echo "Backup file: $BACKUP_FILE"
            else
              echo "‚ö†Ô∏è Response is not valid JSON:"
              echo "$BODY"
            fi
          else
            echo "‚ö†Ô∏è Pre-deployment backup failed (HTTP $HTTP_CODE)"
            echo "This is expected on first deployment or if API is unreachable"
            echo "Response: $BODY"
            echo "Continuing with deployment..."
          fi
        id: pre_backup
        continue-on-error: true

      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.DO_SSH_PRIVATE_KEY }}

      - name: Add DigitalOcean host to known_hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.DO_HOST }} >> ~/.ssh/known_hosts

      - name: Deploy to DigitalOcean
        env:
          DO_HOST: ${{ secrets.DO_HOST }}
          DO_USER: ${{ secrets.DO_USER }}
          OP_SERVICE_ACCOUNT_TOKEN: ${{ secrets.OP_MONGADO_SERVICE_ACCOUNT_TOKEN }}
          ADMIN_PASSKEY: ${{ secrets.ADMIN_PASSKEY }}
          NEXT_PUBLIC_API_URL: ${{ secrets.NEXT_PUBLIC_API_URL }}
          CORS_ORIGINS: ${{ secrets.CORS_ORIGINS }}
          NEO4J_PASSWORD: ${{ secrets.NEO4J_PASSWORD }}
        run: |
          # Pass secrets to remote server via SSH command arguments
          ssh $DO_USER@$DO_HOST "bash -s" \
            "$CORS_ORIGINS" \
            "$OP_SERVICE_ACCOUNT_TOKEN" \
            "$ADMIN_PASSKEY" \
            "$NEXT_PUBLIC_API_URL" \
            "$NEO4J_PASSWORD" << 'EOF'
            set -e

            # Receive arguments
            CORS_ORIGINS="$1"
            OP_SERVICE_ACCOUNT_TOKEN="$2"
            ADMIN_PASSKEY="$3"
            NEXT_PUBLIC_API_URL="$4"
            NEO4J_PASSWORD="$5"

            echo "üì¶ Deploying Mongado to production..."

            # Navigate to project directory
            cd /opt/mongado || { echo "Project directory not found"; exit 1; }

            # Pull latest changes
            echo "üîÑ Pulling latest code from main branch..."
            git fetch origin
            git reset --hard origin/main

            # Tag this deployment for potential rollback
            DEPLOYMENT_TAG="deployment-$(date +%s)"
            echo "üè∑Ô∏è  Tagging deployment as: $DEPLOYMENT_TAG"
            git tag "$DEPLOYMENT_TAG" || echo "‚ö†Ô∏è  Failed to create deployment tag (non-critical)"

            # Create/update environment files
            echo "üîê Setting up environment variables..."

            # Backend .env file
            echo "DEBUG=false" > backend/.env
            echo "CORS_ORIGINS=$CORS_ORIGINS" >> backend/.env
            echo "OP_MONGADO_SERVICE_ACCOUNT_TOKEN=$OP_SERVICE_ACCOUNT_TOKEN" >> backend/.env
            echo "ADMIN_TOKEN=$ADMIN_PASSKEY" >> backend/.env

            # Root .env file for docker-compose (so env vars persist across manual runs)
            echo "NEXT_PUBLIC_API_URL=$NEXT_PUBLIC_API_URL" > .env
            echo "OP_MONGADO_SERVICE_ACCOUNT_TOKEN=$OP_SERVICE_ACCOUNT_TOKEN" >> .env
            echo "NEO4J_PASSWORD=$NEO4J_PASSWORD" >> .env
            echo "NEO4J_AUTH=neo4j/$NEO4J_PASSWORD" >> .env

            # Export environment variables for docker-compose (for this session)
            export NEXT_PUBLIC_API_URL="$NEXT_PUBLIC_API_URL"
            export OP_MONGADO_SERVICE_ACCOUNT_TOKEN="$OP_SERVICE_ACCOUNT_TOKEN"
            export NEO4J_PASSWORD="$NEO4J_PASSWORD"
            export NEO4J_AUTH="neo4j/$NEO4J_PASSWORD"

            # Build and restart containers (without --no-cache to reduce resource usage)
            echo "üê≥ Building and restarting Docker containers..."
            docker compose -f docker-compose.prod.yml build
            docker compose -f docker-compose.prod.yml up -d

            # Wait for services to be healthy
            echo "‚è≥ Waiting for services to be healthy..."
            sleep 10

            # Restart backend to invalidate article cache
            # This ensures new/updated articles are picked up immediately
            echo "üîÑ Restarting backend to invalidate article cache..."
            docker compose -f docker-compose.prod.yml restart backend

            # Pull Ollama model if not already present (use 1B model for 4GB RAM server)
            echo "ü§ñ Setting up Ollama model..."
            docker exec mongado-ollama-prod ollama pull llama3.2:1b || echo "‚ö†Ô∏è  Failed to pull Ollama model, will retry on next deployment"

            # Wait for backend to fully restart before health check
            echo "‚è≥ Waiting for backend to fully restart..."
            sleep 15

            # Health check with retry logic
            echo "üè• Running health checks..."
            RETRY_COUNT=0
            MAX_RETRIES=5
            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              if curl -f http://localhost:8000/ > /dev/null 2>&1; then
                echo "‚úÖ Backend is healthy"
                break
              else
                RETRY_COUNT=$((RETRY_COUNT + 1))
                if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                  echo "‚è≥ Backend not ready yet, retrying in 5s... ($RETRY_COUNT/$MAX_RETRIES)"
                  sleep 5
                else
                  echo "‚ùå Backend health check failed after $MAX_RETRIES attempts"
                  docker compose -f docker-compose.prod.yml logs backend
                  exit 1
                fi
              fi
            done

            # Check frontend health with retry logic
            echo "üè• Checking frontend health..."
            RETRY_COUNT=0
            MAX_RETRIES=5
            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              if curl -f http://localhost:3000/ > /dev/null 2>&1; then
                echo "‚úÖ Frontend is healthy"
                break
              else
                RETRY_COUNT=$((RETRY_COUNT + 1))
                if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                  echo "‚è≥ Frontend not ready yet, retrying in 5s... ($RETRY_COUNT/$MAX_RETRIES)"
                  sleep 5
                else
                  echo "‚ùå Frontend health check failed after $MAX_RETRIES attempts"
                  docker compose -f docker-compose.prod.yml logs frontend
                  exit 1
                fi
              fi
            done

            # Clean up old images and build cache
            echo "üßπ Cleaning up old Docker images and build cache..."
            docker image prune -f
            docker builder prune -f

            echo "‚úÖ Deployment complete!"
          EOF

      - name: Check database health
        env:
          ADMIN_TOKEN: ${{ secrets.ADMIN_TOKEN }}
        run: |
          echo "üè• Checking database health..."
          echo "‚è≥ Waiting for API to be ready (up to 60 seconds)..."

          # Wait for API to be ready with retry logic
          MAX_ATTEMPTS=12
          ATTEMPT=0
          API_READY=false

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            echo "Attempt $ATTEMPT/$MAX_ATTEMPTS..."

            # Check if API returns valid JSON
            HTTP_CODE=$(curl -s -o /tmp/health.json -w "%{http_code}" https://api.mongado.com/api/admin/health/database)

            if [ "$HTTP_CODE" = "200" ] && jq -e . /tmp/health.json >/dev/null 2>&1; then
              echo "‚úÖ API is ready"
              API_READY=true
              break
            else
              echo "API not ready yet (HTTP $HTTP_CODE), waiting 5 seconds..."
              sleep 5
            fi
          done

          if [ "$API_READY" = "false" ]; then
            echo "‚ö†Ô∏è API did not become ready in time, skipping health check"
            exit 0
          fi

          # Parse health response
          HEALTH=$(cat /tmp/health.json)
          echo "$HEALTH" | jq '.'

          # Check if database needs restore
          NEEDS_RESTORE=$(echo "$HEALTH" | jq -r '.needs_restore // false')
          if [ "$NEEDS_RESTORE" = "true" ]; then
            echo "‚ö†Ô∏è Database is empty but backups are available"
            echo "üîÑ Triggering automatic restore from latest backup..."

            RESTORE_RESPONSE=$(curl -s -X POST https://api.mongado.com/api/admin/restore \
              -H "Authorization: Bearer $ADMIN_TOKEN" \
              -H "Content-Type: application/json" \
              -d '{}' \
              --max-time 600)

            echo "$RESTORE_RESPONSE" | jq '.'

            RESTORE_STATUS=$(echo "$RESTORE_RESPONSE" | jq -r '.status // "failed"')
            if [ "$RESTORE_STATUS" = "success" ]; then
              echo "‚úÖ Database restored successfully"
            else
              echo "‚ùå Database restore failed"
              exit 1
            fi
          else
            echo "‚úÖ Database is healthy ($(echo "$HEALTH" | jq -r '.notes_count // 0') notes)"
          fi

      - name: Create post-deployment backup
        env:
          ADMIN_TOKEN: ${{ secrets.ADMIN_TOKEN }}
        run: |
          echo "üíæ Creating post-deployment backup..."

          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST https://api.mongado.com/api/admin/backup \
            -H "Authorization: Bearer $ADMIN_TOKEN" \
            --max-time 300 2>&1 || echo -e "\n000")

          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | sed '$d')

          if [ "$HTTP_CODE" = "200" ]; then
            echo "‚úÖ Post-deployment backup created successfully"
            # Only parse JSON if it's valid
            if echo "$BODY" | jq -e . >/dev/null 2>&1; then
              echo "$BODY" | jq '.'
              BACKUP_FILE=$(echo "$BODY" | jq -r '.backup_file // "unknown"')
              echo "Backup file: $BACKUP_FILE"
            else
              echo "‚ö†Ô∏è Response is not valid JSON:"
              echo "$BODY"
            fi
          else
            echo "‚ö†Ô∏è Post-deployment backup failed (HTTP $HTTP_CODE)"
            echo "Response: $BODY"
            echo "Deployment was successful, but backup should be created manually"
          fi
        continue-on-error: true

      - name: Deployment notification
        if: always()
        run: |
          if [ ${{ job.status }} == 'success' ]; then
            echo "‚úÖ Deployment successful!"
          else
            echo "‚ùå Deployment failed!"
          fi

      - name: Verify deployment
        run: |
          echo "üîç Verifying production deployment..."
          echo "‚è≥ Waiting for external endpoints to be ready..."

          # Check backend API with retry logic
          echo "Checking backend API..."
          RETRY_COUNT=0
          MAX_RETRIES=6
          BACKEND_READY=false
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            BACKEND_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://api.mongado.com/ || echo "000")
            if [ "$BACKEND_STATUS" = "200" ]; then
              echo "‚úÖ Backend API responding (Status: $BACKEND_STATUS)"
              BACKEND_READY=true
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "‚è≥ Backend API not ready (Status: $BACKEND_STATUS), retrying in 10s... ($RETRY_COUNT/$MAX_RETRIES)"
                sleep 10
              else
                echo "‚ùå Backend API failed to respond after $MAX_RETRIES attempts (Status: $BACKEND_STATUS)"
              fi
            fi
          done

          # Check frontend with retry logic
          echo "Checking frontend..."
          RETRY_COUNT=0
          FRONTEND_READY=false
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            FRONTEND_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://mongado.com/ || echo "000")
            if [ "$FRONTEND_STATUS" = "200" ]; then
              echo "‚úÖ Frontend responding (Status: $FRONTEND_STATUS)"
              FRONTEND_READY=true
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "‚è≥ Frontend not ready (Status: $FRONTEND_STATUS), retrying in 10s... ($RETRY_COUNT/$MAX_RETRIES)"
                sleep 10
              else
                echo "‚ùå Frontend failed to respond after $MAX_RETRIES attempts (Status: $FRONTEND_STATUS)"
              fi
            fi
          done

          # Fail if either endpoint didn't become ready
          if [ "$BACKEND_READY" = "false" ] || [ "$FRONTEND_READY" = "false" ]; then
            echo "‚ùå Deployment verification failed - services not responding"
            exit 1
          fi

          echo "‚úÖ All external endpoints verified"

  # Rollback if deployment fails
  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: deploy
    if: failure()

    steps:
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.DO_SSH_PRIVATE_KEY }}

      - name: Add DigitalOcean host to known_hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.DO_HOST }} >> ~/.ssh/known_hosts

      - name: Rollback deployment
        env:
          DO_HOST: ${{ secrets.DO_HOST }}
          DO_USER: ${{ secrets.DO_USER }}
        run: |
          ssh $DO_USER@$DO_HOST << 'EOF'
            set -e

            echo "‚ö†Ô∏è  Deployment failed, attempting rollback..."

            cd /opt/mongado

            # Find the previous successful deployment tag
            # List all deployment tags, sort by timestamp, and get the second-to-last one
            PREV_TAG=$(git tag -l 'deployment-*' | sort -V | tail -2 | head -1)

            if [ -z "$PREV_TAG" ]; then
              echo "‚ùå No previous deployment tag found"
              echo "‚ö†Ô∏è  Falling back to HEAD~1 (use with caution)"
              git reset --hard HEAD~1
            else
              echo "üîÑ Rolling back to previous deployment: $PREV_TAG"
              git reset --hard "$PREV_TAG"

              # Verify the rollback target exists
              if ! git rev-parse --verify "$PREV_TAG" >/dev/null 2>&1; then
                echo "‚ùå Rollback tag $PREV_TAG does not exist"
                exit 1
              fi

              echo "‚úÖ Rolled back to $PREV_TAG"
            fi

            # Restart containers with previous version
            echo "üê≥ Restarting containers with previous version..."
            docker compose -f docker-compose.prod.yml build
            docker compose -f docker-compose.prod.yml up -d

            # Wait for services to restart
            echo "‚è≥ Waiting for services to restart..."
            sleep 15

            # Verify rollback was successful
            echo "üè• Verifying rollback..."
            if curl -f http://localhost:8000/ > /dev/null 2>&1; then
              echo "‚úÖ Backend is healthy after rollback"
            else
              echo "‚ö†Ô∏è  Backend health check failed after rollback"
            fi

            if curl -f http://localhost:3000/ > /dev/null 2>&1; then
              echo "‚úÖ Frontend is healthy after rollback"
            else
              echo "‚ö†Ô∏è  Frontend health check failed after rollback"
            fi

            echo "‚úÖ Rollback complete"
          EOF
