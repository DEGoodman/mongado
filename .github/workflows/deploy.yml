name: Deploy to DigitalOcean

on:
  push:
    branches: [main]
    paths-ignore:
      - 'backend/static/assets/**'  # Ignore non-article assets
      - 'docs/**'  # Ignore documentation
      - 'README.md'  # Ignore root README
      # Note: We DO deploy on article changes to invalidate backend cache
  workflow_dispatch:  # Allow manual deployment

jobs:
  # Deploy to production (CI must pass first via branch protection or ci.yml trigger)
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create pre-deployment backup
        env:
          ADMIN_TOKEN: ${{ secrets.ADMIN_TOKEN }}
        run: |
          echo "ðŸ“¦ Creating pre-deployment backup..."

          # Attempt backup via API (may fail on first deployment)
          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST https://api.mongado.com/api/admin/backup \
            -H "Authorization: Bearer $ADMIN_TOKEN" \
            --max-time 300 2>&1 || echo -e "\n000")

          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | sed '$d')

          if [ "$HTTP_CODE" = "200" ]; then
            echo "âœ… Pre-deployment backup created successfully"
            echo "$BODY" | jq '.'
            BACKUP_FILE=$(echo "$BODY" | jq -r '.backup_file // "unknown"')
            echo "backup_file=$BACKUP_FILE" >> $GITHUB_OUTPUT
            echo "Backup file: $BACKUP_FILE"
          else
            echo "âš ï¸ Pre-deployment backup failed (HTTP $HTTP_CODE)"
            echo "This is expected on first deployment or if API is unreachable"
            echo "Response: $BODY"
            echo "Continuing with deployment..."
          fi
        id: pre_backup
        continue-on-error: true

      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.DO_SSH_PRIVATE_KEY }}

      - name: Add DigitalOcean host to known_hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.DO_HOST }} >> ~/.ssh/known_hosts

      - name: Deploy to DigitalOcean
        env:
          DO_HOST: ${{ secrets.DO_HOST }}
          DO_USER: ${{ secrets.DO_USER }}
          OP_SERVICE_ACCOUNT_TOKEN: ${{ secrets.OP_MONGADO_SERVICE_ACCOUNT_TOKEN }}
          ADMIN_PASSKEY: ${{ secrets.ADMIN_PASSKEY }}
          NEXT_PUBLIC_API_URL: ${{ secrets.NEXT_PUBLIC_API_URL }}
          CORS_ORIGINS: ${{ secrets.CORS_ORIGINS }}
          NEO4J_PASSWORD: ${{ secrets.NEO4J_PASSWORD }}
        run: |
          # Pass secrets to remote server via SSH command arguments
          ssh $DO_USER@$DO_HOST "bash -s" \
            "$CORS_ORIGINS" \
            "$OP_SERVICE_ACCOUNT_TOKEN" \
            "$ADMIN_PASSKEY" \
            "$NEXT_PUBLIC_API_URL" \
            "$NEO4J_PASSWORD" << 'EOF'
            set -e

            # Receive arguments
            CORS_ORIGINS="$1"
            OP_SERVICE_ACCOUNT_TOKEN="$2"
            ADMIN_PASSKEY="$3"
            NEXT_PUBLIC_API_URL="$4"
            NEO4J_PASSWORD="$5"

            echo "ðŸ“¦ Deploying Mongado to production..."

            # Navigate to project directory
            cd /opt/mongado || { echo "Project directory not found"; exit 1; }

            # Pull latest changes
            echo "ðŸ”„ Pulling latest code from main branch..."
            git fetch origin
            git reset --hard origin/main

            # Create/update environment files
            echo "ðŸ” Setting up environment variables..."

            # Backend .env file
            echo "DEBUG=false" > backend/.env
            echo "CORS_ORIGINS=$CORS_ORIGINS" >> backend/.env
            echo "OP_MONGADO_SERVICE_ACCOUNT_TOKEN=$OP_SERVICE_ACCOUNT_TOKEN" >> backend/.env
            echo "ADMIN_TOKEN=$ADMIN_PASSKEY" >> backend/.env

            # Root .env file for docker-compose (so env vars persist across manual runs)
            echo "NEXT_PUBLIC_API_URL=$NEXT_PUBLIC_API_URL" > .env
            echo "OP_MONGADO_SERVICE_ACCOUNT_TOKEN=$OP_SERVICE_ACCOUNT_TOKEN" >> .env
            echo "NEO4J_PASSWORD=$NEO4J_PASSWORD" >> .env
            echo "NEO4J_AUTH=neo4j/$NEO4J_PASSWORD" >> .env

            # Export environment variables for docker-compose (for this session)
            export NEXT_PUBLIC_API_URL="$NEXT_PUBLIC_API_URL"
            export OP_MONGADO_SERVICE_ACCOUNT_TOKEN="$OP_SERVICE_ACCOUNT_TOKEN"
            export NEO4J_PASSWORD="$NEO4J_PASSWORD"
            export NEO4J_AUTH="neo4j/$NEO4J_PASSWORD"

            # Build and restart containers (without --no-cache to reduce resource usage)
            echo "ðŸ³ Building and restarting Docker containers..."
            docker compose -f docker-compose.prod.yml build
            docker compose -f docker-compose.prod.yml up -d

            # Wait for services to be healthy
            echo "â³ Waiting for services to be healthy..."
            sleep 10

            # Restart backend to invalidate article cache
            # This ensures new/updated articles are picked up immediately
            echo "ðŸ”„ Restarting backend to invalidate article cache..."
            docker compose -f docker-compose.prod.yml restart backend

            # Pull Ollama model if not already present (use 1B model for 4GB RAM server)
            echo "ðŸ¤– Setting up Ollama model..."
            docker exec mongado-ollama-prod ollama pull llama3.2:1b || echo "âš ï¸  Failed to pull Ollama model, will retry on next deployment"

            # Wait for backend to fully restart before health check
            echo "â³ Waiting for backend to fully restart..."
            sleep 15

            # Health check with retry logic
            echo "ðŸ¥ Running health checks..."
            RETRY_COUNT=0
            MAX_RETRIES=5
            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              if curl -f http://localhost:8000/ > /dev/null 2>&1; then
                echo "âœ… Backend is healthy"
                break
              else
                RETRY_COUNT=$((RETRY_COUNT + 1))
                if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                  echo "â³ Backend not ready yet, retrying in 5s... ($RETRY_COUNT/$MAX_RETRIES)"
                  sleep 5
                else
                  echo "âŒ Backend health check failed after $MAX_RETRIES attempts"
                  docker compose -f docker-compose.prod.yml logs backend
                  exit 1
                fi
              fi
            done

            # Check frontend health (single attempt is fine, it starts faster)
            echo "ðŸ¥ Checking frontend health..."
            if curl -f http://localhost:3000/ > /dev/null 2>&1; then
              echo "âœ… Frontend is healthy"
            else
              echo "âŒ Frontend health check failed"
              docker compose -f docker-compose.prod.yml logs frontend
              exit 1
            fi

            # Clean up old images and build cache
            echo "ðŸ§¹ Cleaning up old Docker images and build cache..."
            docker image prune -f
            docker builder prune -f

            echo "âœ… Deployment complete!"
          EOF

      - name: Check database health
        env:
          ADMIN_TOKEN: ${{ secrets.ADMIN_TOKEN }}
        run: |
          echo "ðŸ¥ Checking database health..."

          HEALTH=$(curl -s https://api.mongado.com/api/admin/health/database || echo '{"status":"unreachable"}')
          echo "$HEALTH" | jq '.'

          # Check if database needs restore
          NEEDS_RESTORE=$(echo "$HEALTH" | jq -r '.needs_restore // false')
          if [ "$NEEDS_RESTORE" = "true" ]; then
            echo "âš ï¸ Database is empty but backups are available"
            echo "ðŸ”„ Triggering automatic restore from latest backup..."

            RESTORE_RESPONSE=$(curl -s -X POST https://api.mongado.com/api/admin/restore \
              -H "Authorization: Bearer $ADMIN_TOKEN" \
              -H "Content-Type: application/json" \
              -d '{}' \
              --max-time 600)

            echo "$RESTORE_RESPONSE" | jq '.'

            RESTORE_STATUS=$(echo "$RESTORE_RESPONSE" | jq -r '.status // "failed"')
            if [ "$RESTORE_STATUS" = "success" ]; then
              echo "âœ… Database restored successfully"
            else
              echo "âŒ Database restore failed"
              exit 1
            fi
          else
            echo "âœ… Database is healthy ($(echo "$HEALTH" | jq -r '.notes_count // 0') notes)"
          fi

      - name: Create post-deployment backup
        env:
          ADMIN_TOKEN: ${{ secrets.ADMIN_TOKEN }}
        run: |
          echo "ðŸ’¾ Creating post-deployment backup..."

          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST https://api.mongado.com/api/admin/backup \
            -H "Authorization: Bearer $ADMIN_TOKEN" \
            --max-time 300 2>&1 || echo -e "\n000")

          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | sed '$d')

          if [ "$HTTP_CODE" = "200" ]; then
            echo "âœ… Post-deployment backup created successfully"
            echo "$BODY" | jq '.'
            BACKUP_FILE=$(echo "$BODY" | jq -r '.backup_file // "unknown"')
            echo "Backup file: $BACKUP_FILE"
          else
            echo "âš ï¸ Post-deployment backup failed (HTTP $HTTP_CODE)"
            echo "Response: $BODY"
            echo "Deployment was successful, but backup should be created manually"
          fi
        continue-on-error: true

      - name: Deployment notification
        if: always()
        run: |
          if [ ${{ job.status }} == 'success' ]; then
            echo "âœ… Deployment successful!"
          else
            echo "âŒ Deployment failed!"
          fi

      - name: Verify deployment
        run: |
          echo "ðŸ” Verifying production deployment..."
          sleep 5

          # Check backend API
          BACKEND_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://api.mongado.com/ || echo "000")
          if [ "$BACKEND_STATUS" = "200" ]; then
            echo "âœ… Backend API responding (Status: $BACKEND_STATUS)"
          else
            echo "âš ï¸  Backend API status: $BACKEND_STATUS"
          fi

          # Check frontend
          FRONTEND_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://mongado.com/ || echo "000")
          if [ "$FRONTEND_STATUS" = "200" ]; then
            echo "âœ… Frontend responding (Status: $FRONTEND_STATUS)"
          else
            echo "âš ï¸  Frontend status: $FRONTEND_STATUS"
          fi

  # Rollback if deployment fails
  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: deploy
    if: failure()

    steps:
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.DO_SSH_PRIVATE_KEY }}

      - name: Add DigitalOcean host to known_hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.DO_HOST }} >> ~/.ssh/known_hosts

      - name: Rollback deployment
        env:
          DO_HOST: ${{ secrets.DO_HOST }}
          DO_USER: ${{ secrets.DO_USER }}
        run: |
          ssh $DO_USER@$DO_HOST << 'EOF'
            set -e

            echo "âš ï¸  Deployment failed, attempting rollback..."

            cd /opt/mongado

            # Rollback to previous git commit
            git reset --hard HEAD~1

            # Restart containers with previous version
            docker compose -f docker-compose.prod.yml up -d

            echo "âœ… Rollback complete"
          EOF
